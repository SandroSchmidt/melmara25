<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Externe Daten/Libs -->
  <script src="./roaddata-devi.js"></script>
  <script src="./d3.min.js"></script>
  <script src="./run26fg.js"></script>
<script src="./mapbox_token.local.js"></script>
  <!-- Mapbox GL -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>

  <title>MEL_MARA_SIM26</title>

  <style>
    :root{
      --bg: #0b0f17;
      --panel: #101827;
      --panel2:#0f172a;
      --border:#1f2a44;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --radius: 14px;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; margin:0; }

    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, rgba(59,130,246,.25), transparent 60%),
                  radial-gradient(900px 500px at 80% 10%, rgba(16,185,129,.18), transparent 55%),
                  var(--bg);
      color: var(--text);
      overflow:hidden;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px;
    }

    .toolbar{
      background: linear-gradient(180deg, rgba(16,24,39,.92), rgba(16,24,39,.78));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:10px;
    }

    .toolbar__row{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .toolbar__group{ display:flex; gap:8px; align-items:center; }
    .toolbar__group--right{ margin-left:auto; }

    .btn{
      border:1px solid var(--border);
      background: rgba(59,130,246,.18);
      color: var(--text);
      padding:8px 10px;
      border-radius: 10px;
      cursor:pointer;
    }
    .btn:hover{ filter: brightness(1.08); }
    .btn--ghost{ background: rgba(255,255,255,.04); }

    .slider{
      flex: 1 1 420px;
      min-width: 260px;
    }

    .field{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 10px;
    }
    .field > span{ color: var(--muted); font-size:12px; }
    .field input{
      width: 110px;
      background: transparent;
      border: none;
      color: var(--text);
      outline:none;
    }
    .field input[type="checkbox"]{ width:auto; }

    .kpi{
      display:flex;
      gap:10px;
      align-items:center;
      padding:6px 8px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 10px;
    }
    .kpi__item{ display:flex; flex-direction:column; line-height:1.1; }
    .kpi__label{ color: var(--muted); font-size:12px; }
    .kpi__value{ font-variant-numeric: tabular-nums; font-size:14px; }

    .content{
      flex:1;
      min-height:0;
      display:flex;
      gap:12px;
    }

    .pane{ min-height:0; }

    .pane--map{
      flex: 0 0 60%;
      background: rgba(255,255,255,.02);
      border:1px solid var(--border);
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
    }

    .mapboxgl-popup-content,
    .mapboxgl-popup-content * { color: #000; }

    #map{ width:100%; height:100%; }

    .pane--charts{
      flex: 1 1 auto;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
      min-width: 0;
    }

    .card{
      flex: 1 1 50%;
      min-height:0;
      background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(15,23,42,.72));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      min-width: 0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .card__title{
      padding:10px 12px;
      border-bottom:1px solid rgba(31,42,68,.8);
      color: var(--text);
      font-size: 13px;
      letter-spacing: .2px;
    }
    .card__body{
      flex:1;
      min-height:0;
      min-width: 0;
      padding:10px;
    }

    /* =========================
       Settings Drawer (rechts)
       ========================= */
    .drawer{
      position: fixed;
      top: 0;
      right: 0;
      height: 100%;
      width: 360px;
      max-width: calc(100vw - 40px);
      background: linear-gradient(180deg, rgba(16,24,39,.96), rgba(15,23,42,.92));
      border-left: 1px solid var(--border);
      box-shadow: var(--shadow);
      transform: translateX(100%);
      transition: transform 180ms ease;
      z-index: 1000;
      display:flex;
      flex-direction:column;
    }
    .drawer.is-open{ transform: translateX(0); }

    .drawer__header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      border-bottom:1px solid rgba(31,42,68,.8);
    }
    .drawer__title{
      font-size: 13px;
      letter-spacing:.2px;
      color: var(--text);
    }
    .drawer__body{
      padding:12px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .drawer__section{
      border:1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      padding:10px;
    }
    .drawer__section-title{
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 10px;
    }
    .drawer__grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }

    .backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.35);
      z-index: 999;
      display:none;
    }
    .backdrop.is-open{ display:block; }

    /* Original überschreibende body-Regel (beibehalten) */
    body { font-family: Arial, sans-serif; }
  </style>
</head>

<body>
  <div class="app">

    <header class="toolbar">
      <div class="toolbar__row">
        <div class="toolbar__group">
          <button class="btn" id="playbut" onclick="
            play = !play;
            if (play) realtime = false;
            syncPlayUI();
            zeitgewahlt(Math.round(tim));
          ">play</button>

          <button class="btn" id="realbutton" onclick="
            realtime = !realtime;
            if (realtime) play = false;
            syncPlayUI();
            zeitgewahlt(Math.round(tim));
          ">realtime</button>

          <button class="btn btn--ghost" onclick="
            map.setPitch(45); map.setBearing(0); map.setZoom(12); map.setCenter([144.94,-37.8173614]);
            d3.select('#gu1').property('value','45');
            d3.select('#gu2').property('value','0');
            d3.select('#gu3').property('value','15');
            zeitgewahlt(360); tim=360;
            play = false;
            realtime = false;
            syncPlayUI();
          ">reset</button>
        </div>

        <div class="toolbar__group toolbar__group--right">
          <button class="btn btn--ghost" id="settingsBtn" type="button">settings</button>
        </div>
      </div>

      <div class="toolbar__row">
        <input class="slider" type="range" id="myRange"
          onchange="if(play==false){tim=Math.round(this.value); zeitgewahlt(Math.round(tim));}"
          value="60" min="360" max="900" step="1" />

        <div class="kpi">
          <div class="kpi__item">
            <span class="kpi__label">time</span>
            <span id="uhr" class="kpi__value">00:00</span>
          </div>
          <div class="kpi__item">
            <span class="kpi__label">guntime</span>
            <span id="gunuhr" class="kpi__value">00:00</span>
          </div>
        </div>
      </div>
    </header>

    <main class="content">
      <section class="pane pane--map">
        <div id="map"></div>
      </section>

      <aside class="pane pane--charts">
        <section class="card">
          <div id="timelineChartTitle"  class="card__title">Timeline</div>
          <div id="chartTime" class="card__body"></div>
        </section>

        <section class="card">
          <div id="chartDistanceTitle" class="card__title">Runners per 100m at current time</div>
          <div id="chartDistance" class="card__body"></div>
        </section>
      </aside>
    </main>
  </div>

  <div class="backdrop" id="settingsBackdrop"></div>

  <aside class="drawer" id="settingsDrawer" aria-hidden="true">
    <div class="drawer__header">
      <div class="drawer__title">Settings</div>
      <button class="btn btn--ghost" id="settingsCloseBtn" type="button">close</button>
    </div>

    <div class="drawer__body">
      <div class="drawer__section">
        <div class="drawer__section-title">Playback & Camera</div>
        <div class="drawer__grid">
          <label class="field">
            <span>speed</span>
            <input value="5" id="spedset" type="number" min="1" max="10"
              onchange="autoplayspeed = (+this.value||5)/10;"/>
          </label>

          <label class="field">
            <span>pitch</span>
            <input id="gu1" type="number" value="45" step="1" min="15" max="90" oninput="map.setPitch(90-this.value)"/>
          </label>

          <label class="field">
            <span>bearing</span>
            <input id="gu2" type="number" value="0" step="1" min="-90" max="90" oninput="map.setBearing(this.value)"/>
          </label>

          <label class="field">
            <span>zoom</span>
            <input id="gu3" type="number" value="15" step="0.1" min="12" max="17" oninput="map.setZoom(this.value)"/>
          </label>
        </div>
      </div>

      <div class="drawer__section">
        <div class="drawer__section-title">Race start times</div>
        <div class="drawer__grid">
          <label class="field">
            <span>marathon</span>
            <input id="maratimset" type="time"
              onchange="setRaceStart('mara', convertTimeToMinutes(this.value)); if(!play){zeitgewahlt(Math.round(tim));}"/>
          </label>

          <label class="field">
            <span>halfmarathon</span>
            <input id="halftimset" type="time"
              onchange="setRaceStart('half', convertTimeToMinutes(this.value)); if(!play){zeitgewahlt(Math.round(tim));}"/>
          </label>

          <label class="field">
            <span>10km run</span>
            <input id="tenkmtimset" type="time"
              onchange="setRaceStart('tenkm', convertTimeToMinutes(this.value)); if(!play){zeitgewahlt(Math.round(tim));}"/>
          </label>

          <label class="field">
            <span>5km run</span>
            <input id="fivekmtimset" type="time"
              onchange="setRaceStart('fivekm', convertTimeToMinutes(this.value)); if(!play){zeitgewahlt(Math.round(tim));}"/>
          </label>

          <label class="field">
            <span>3km run</span>
            <input id="twofivetimset" type="time"
              onchange="setRaceStart('twofive', convertTimeToMinutes(this.value)); if(!play){zeitgewahlt(Math.round(tim));}"/>
          </label>
        </div>
      </div>

      <div class="drawer__section">
        <div class="drawer__section-title">Visible races</div>
        <div class="drawer__grid">
          <label class="field">
            <input id="chk_mara" type="checkbox"
              onchange="setRaceActive('mara', this.checked); zeitgewahlt(Math.round(tim));">
            <span>marathon</span>
          </label>

          <label class="field">
            <input id="chk_half" type="checkbox"
              onchange="setRaceActive('half', this.checked); zeitgewahlt(Math.round(tim));">
            <span>halfmarathon</span>
          </label>

          <label class="field">
            <input id="chk_tenkm" type="checkbox"
              onchange="setRaceActive('tenkm', this.checked); zeitgewahlt(Math.round(tim));">
            <span>10km run</span>
          </label>

          <label class="field">
            <input id="chk_fivekm" type="checkbox"
              onchange="setRaceActive('fivekm', this.checked); zeitgewahlt(Math.round(tim));">
            <span>5km run</span>
          </label>

          <label class="field">
            <input id="chk_twofive" type="checkbox"
              onchange="setRaceActive('twofive', this.checked); zeitgewahlt(Math.round(tim));">
            <span>3 km run</span>
          </label>
        </div>
      </div>
    </div>
  </aside>

  <script>
    /* =========================================
       UI: Settings Drawer (nur Anzeige/Interaktion)
       ========================================= */
    (function initSettingsDrawer(){
      const btn = document.getElementById('settingsBtn');
      const drawer = document.getElementById('settingsDrawer');
      const backdrop = document.getElementById('settingsBackdrop');
      const closeBtn = document.getElementById('settingsCloseBtn');

      function openDrawer(){
        drawer.classList.add('is-open');
        backdrop.classList.add('is-open');
        drawer.setAttribute('aria-hidden','false');
      }
      function closeDrawer(){
        drawer.classList.remove('is-open');
        backdrop.classList.remove('is-open');
        drawer.setAttribute('aria-hidden','true');
      }

      btn.addEventListener('click', openDrawer);
      closeBtn.addEventListener('click', closeDrawer);
      backdrop.addEventListener('click', closeDrawer);
      window.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeDrawer(); });
    })();

    /* =========================================
       Helper: Zeit-Konvertierung
       ========================================= */
    function convertTimeToMinutes(time) {
      if (!time || typeof time !== "string" || time.indexOf(":") === -1) return 0;
      const [hours, minutes] = time.split(':').map(Number);
      return (hours * 60) + minutes;
    }
    function convertMinutesToTime(temp) {
      const t = Math.max(0, Math.round(+temp || 0));
      const hours = Math.floor(t / 60);
      const minutes = t % 60;
      return String(hours).padStart(2, '0') + ":" + String(minutes).padStart(2, '0');
    }

    /* =========================
       LocalStorage: Settings
       FIX: Settings-Block MUSS vor erstem loadSettings() stehen.
       ========================= */
    const LS_KEY = "mel_mara_sim26_settings_v1";

    function defaultSettings(){
      return {
        delay: {
          mara: 60 + 330,
          half: 120 + 330,
          tenkm: 90 + 330,
          fivekm: 330 + 345,
          twofive: 360 + 345
        },
        activeRaces: {
          mara: true,
          half: true,
          tenkm: false,
          fivekm: false,
          twofive: false
        }
      };
    }

    function loadSettings(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return defaultSettings();
        const parsed = JSON.parse(raw);
        const def = defaultSettings();
        const out = {
          delay: { ...def.delay, ...(parsed.delay || {}) },
          activeRaces: { ...def.activeRaces, ...(parsed.activeRaces || {}) }
        };
        Object.keys(out.delay).forEach(k => {
          const v = out.delay[k];
          if (typeof v !== "number" || !isFinite(v)) out.delay[k] = def.delay[k];
        });
        Object.keys(out.activeRaces).forEach(k => { out.activeRaces[k] = !!out.activeRaces[k]; });
        return out;
      }catch(e){
        console.warn("[settings] load failed, using defaults", e);
        return defaultSettings();
      }
    }

    function saveSettings(){
      try{
        const payload = {
          delay: {
            mara: delay.mara,
            half: delay.half,
            tenkm: delay.tenkm,
            fivekm: delay.fivekm,
            twofive: delay.twofive
          },
          activeRaces: {
            mara: !!activeRaces.mara,
            half: !!activeRaces.half,
            tenkm: !!activeRaces.tenkm,
            fivekm: !!activeRaces.fivekm,
            twofive: !!activeRaces.twofive
          }
        };
        localStorage.setItem(LS_KEY, JSON.stringify(payload));
      }catch(e){
        console.warn("[settings] save failed", e);
      }
    }

    function setRaceStart(raceKey, minutes){
      delay[raceKey] = minutes;
      if (raceKey === "mara" && delay.marafull !== undefined) delay.marafull = minutes;
      saveSettings();
      applySettingsToUI(); // hält UI konsistent, falls Browser time-input normalisiert
    }

    function setRaceActive(raceKey, isOn){
      activeRaces[raceKey] = !!isOn;
      saveSettings();
    }

    function applySettingsToUI(){
      const mapTimes = { mara:"maratimset", half:"halftimset", tenkm:"tenkmtimset", fivekm:"fivekmtimset", twofive:"twofivetimset" };
      Object.keys(mapTimes).forEach(k => {
        const el = document.getElementById(mapTimes[k]);
        if (el) el.value = convertMinutesToTime(delay[k]);
      });

      const ids = { mara:"chk_mara", half:"chk_half", tenkm:"chk_tenkm", fivekm:"chk_fivekm", twofive:"chk_twofive" };
      Object.keys(ids).forEach(k => {
        const el = document.getElementById(ids[k]);
        if (el) el.checked = !!activeRaces[k];
      });

      const sp = document.getElementById("spedset");
      if (sp) autoplayspeed = (+sp.value || 5) / 10;
    }

    /* =========================================
       Original-Logik
       ========================================= */
    realtime = false;
    coltoggle = false;
    play = false;

    const MARATHON_SPEED_KMH = 42.195 / 4;
    const CAPACITY_PER_M = 82;
    const MARATHON_SPEED_MS = MARATHON_SPEED_KMH / 3.6;

    function ceilToHundred(v){
      if (!isFinite(v) || v <= 0) return 100;
      return Math.max(100, Math.ceil(v / 100) * 100);
    }

    function minRoadWidthFromDensity(mengePer100m){
      const densityPerMeter = mengePer100m / 100;
      const flowPerSecond  = densityPerMeter * MARATHON_SPEED_MS;
      const flowPerMinute  = flowPerSecond * 60;
      return flowPerMinute / CAPACITY_PER_M;
    }

    const saved = loadSettings();

    let activeRaces = {
      mara: saved.activeRaces.mara,
      half: saved.activeRaces.half,
      tenkm: saved.activeRaces.tenkm,
      fivekm: saved.activeRaces.fivekm,
      twofive: saved.activeRaces.twofive
    };

    function isRaceActive(key){ return activeRaces[key] === true; }

    filast = { mara:{}, half:{}, tenkm:{}, fivekm:{}, twofive:{} };
    starterzahlen ={ mara:(20000),half:16000,tenkm:15000,fivekm:10000,twofive:3000,marafull:20000}

    autoplayspeed = 0.5;

    coordinates.mara.forEach((item) => { item[1] = item[1] + 0.00005; item[0] = item[0] + 0.00005; });
    coordinates.tenkm.forEach((item) => { item[1] = item[1] - 0.00010; });
    coordinates.half.forEach((item) => { item[1] = item[1] - 0.00005; item[0] = item[0] - 0.00005; });

    let selectedProbe = { raceKey: "mara", segIndex: 0 };

    colorScale = {
      mara: d3.scaleLinear().domain([0, 500]).range(["red","black"]),
      half: d3.scaleLinear().domain([0, 500]).range(["blue","black"]),
      tenkm: d3.scaleLinear().domain([0, 500]).range(["green","black"]),
      fivekm: d3.scaleLinear().domain([0, 500]).range(["pink","black"]),
      twofive: d3.scaleLinear().domain([0, 500]).range(["#09ebdc","black"])
    };

    const mengeScale = d3.scaleLinear().domain([0, 500]).range([3,10]);

    racenames = {
      mara: "marathon",
      marafull:"Marathon (full data)",
      half: "halfmarathon",
      tenkm: "10km run",
      fivekm: "5km run",
      twofive: "3km run"
    };

    cutoff = {
      mara: 8*60 + 360 + 60,
      half: 5*60 + 360 + 120,
      tenkm: 5*60 + 360 + 90,
      fivekm: 3*60 + 330 + 360,
      twofive: 3*60 + 360 + 360,
      marafull: 60 + 330
    };
    cutoff.marafull = cutoff.mara;

    tim = 360;

    let delay = {
      mara: saved.delay.mara,
      half: saved.delay.half,
      tenkm: saved.delay.tenkm,
      fivekm: saved.delay.fivekm,
      twofive: saved.delay.twofive,
      marafull: saved.delay.mara
    };
    delay.marafull = delay.mara;

    applySettingsToUI();
    d3.select("#myRange").property("value", tim);

    linejsons = {};
    pointjsons = {};
    for (const key in coordinates) {
      linejsons[key] = generateColoredGeoJSON(coordinates[key]);
      pointjsons[key] = coordinatesToGeoJSON(coordinates[key]);
    }

    initialise_map();

    let timelineMode = "chart";
    let lastStatusReason = null;

    function zeitgewahlt(timr) {
      if (!markers || markers.length < 12) return;

      markers[3].setLngLat([0,0]);
      markers[4].setLngLat([0,0]);
      markers[5].setLngLat([0,0]);
      markers[6].setLngLat([0,0]);
      markers[7].setLngLat([0,0]);
      markers[8].setLngLat([0,0]);
      markers[9].setLngLat([0,0]);
      markers[10].setLngLat([0,0]);
      markers[11].setLngLat([0,0]);

      d3.select("#myRange").property("value", timr);
      d3.select('#uhr').text(convertMinutesToTime(Math.round(timr)));
      d3.select('#gunuhr').text(convertMinutesToTime(Math.max(0, Math.round(timr - delay.mara))));

      for (const key in coordinates) {
        if (!isRaceActive(key)) {
          map.setLayoutProperty("lines-layer-" + key, "visibility", "none");
          map.setLayoutProperty("circles-layer-" + key, "visibility", "none");
          continue;
        } else {
          map.setLayoutProperty("lines-layer-" + key, "visibility", "visible");
          map.setLayoutProperty("circles-layer-" + key, "visibility", "visible");
        }

        let kk = Math.max(0, timr - delay[key]);
        kkk = kk;

        if (woist[key] && kk < woist[key].length) {
          for (i = 0; i < coordinates[key].length - 1; i++) {
            const row = getDensityRowAbsTime(key, timr);
            menge = runnersPer100mFromRow(row, i);

            strokec = 0;
            stroke = Math.min(10, mengeScale(menge));
            rad = Math.min(10, mengeScale(menge));

            if (menge < 1) { stroke = 0; rad = 0; strokec = 0; }
            col = colorScale[key](menge);
            if (timr < delay[key] || timr > cutoff[key] + delay[key]) { stroke = 0; strokec = 0; rad = 0; }

            const b0 = Math.floor(i / BUCKET_SIZE_25M) * BUCKET_SIZE_25M;
            const bucketKm = (b0 + BUCKET_SIZE_25M / 2) / 40;

            pointjsons[key].features[i+1].properties.radius = rad;
            pointjsons[key].features[i+1].properties.stroke = strokec;
            pointjsons[key].features[i+1].properties.fill = col;

            const minWidth = minRoadWidthFromDensity(menge);
            pointjsons[key].features[i+1].properties.text =
              "<b>" + racenames[key] + "</b><br>" +
              bucketKm.toFixed(2) + " km<br>" +
              convertMinutesToTime(timr) + "<br>" +
              menge + " runners / 100m<br>" +
              "min. road width: " + Math.max(1, minWidth.toFixed(2)) + " m";

            linejsons[key].features[i].properties.stroke = col;
            linejsons[key].features[i].properties.width = stroke;
          }
        } else {
          for (i = 0; i < coordinates[key].length - 1; i++) {
            const b0 = Math.floor(i / BUCKET_SIZE_25M) * BUCKET_SIZE_25M;
            const bucketKm = (b0 + BUCKET_SIZE_25M / 2) / 40;
            pointjsons[key].features[i+1].properties.radius = 0;
            pointjsons[key].features[i+1].properties.stroke = 0;
            pointjsons[key].features[i+1].properties.fill = "yellow";
            pointjsons[key].features[i+1].properties.text =
              "<b>" + racenames[key] + "</b><br> " +
              bucketKm.toFixed(2) + " km <br>" +
              convertMinutesToTime(timr) + " <br> " +
              menge + " runners/100m ";
            linejsons[key].features[i].properties.stroke = "yellow";
            linejsons[key].features[i].properties.width = 0;
          }
        }

        map.getSource('line-segments' + key).setData(linejsons[key]);
        map.getSource('circles' + key).setData(pointjsons[key]);

        if (woist[key] && woist[key][kkk]) filast = findIndices(woist[key][kkk]);

        if (key == "mara") {
          if (filast[0] != 0 && timr < delay[key] + 131) { markers[2].setLngLat(coordinates[key][filast[0] + 1]); } else { markers[2].setLngLat([0,0]); }
          if (filast[1] != 0) { markers[3].setLngLat(coordinates[key][filast[1] - 1]); } else { markers[3].setLngLat([0,0]); }
        }
        if (key == "half") {
          if (filast[0] != 0 && timr < delay[key] + 62) { markers[4].setLngLat(coordinates[key][filast[0] + 1]); } else { markers[4].setLngLat([0,0]); }
          if (filast[1] != 0) { markers[5].setLngLat(coordinates[key][filast[1] - 1]); } else { markers[5].setLngLat([0,0]); }
        }
        if (key == "tenkm") {
          if (filast[0] != 0 && timr < delay[key] + 30) { markers[6].setLngLat(coordinates[key][filast[0] + 1]); } else { markers[6].setLngLat([0,0]); }
          if (filast[1] != 0) { markers[7].setLngLat(coordinates[key][filast[1] - 1]); } else { markers[7].setLngLat([0,0]); }
        }
      }

      updateDistanceChart(timr);
      if (timelineMode === "chart") updateTimelineChart(timr, selectedProbe.raceKey, selectedProbe.segIndex);
      else renderStatusTable(timr);
    }

    setInterval(function () {
      if (tim > 359 + 9*60 && play) { play = false; syncPlayUI(); }
      if (play == true) { tim = tim + autoplayspeed; zeitgewahlt(Math.round(tim)); }
      if (realtime == true) {
        now = new Date();
        tim2 = (now.getHours() * 60) + now.getMinutes();
        if (tim2 > 359.9 && tim2 < 900.1) zeitgewahlt(Math.round(tim2));
      }
    }, 50);

    const keys = ["mara", "half", "tenkm", "fivekm", "twofive"];
    const timelineChart = { svg:null, g:null, width:0, height:0, margin:{top:10,right:16,bottom:28,left:46}, x:null, y:null, xAxisG:null, yAxisG:null, path:null, cursor:null };
    timelineChart.zoom = false;
    timelineChart.zoomWindow = 30;

    function initTimelineChart() {
      const container = document.getElementById("chartTime");
      if (!container) return;
      d3.select(container).selectAll("*").remove();

      const rect = container.getBoundingClientRect();
      timelineChart.width = Math.max(320, rect.width);
      timelineChart.height = Math.max(180, rect.height);

      const innerW = timelineChart.width - timelineChart.margin.left - timelineChart.margin.right;
      const innerH = timelineChart.height - timelineChart.margin.top - timelineChart.margin.bottom;

      timelineChart.svg = d3.select(container).append("svg").attr("width", timelineChart.width).attr("height", timelineChart.height);
      timelineChart.g = timelineChart.svg.append("g").attr("transform", `translate(${timelineChart.margin.left},${timelineChart.margin.top})`);

      timelineChart.x = d3.scaleLinear().domain([360, 900]).range([0, innerW]);
      timelineChart.y = d3.scaleLinear().domain([0, 200]).range([innerH, 0]);

      timelineChart.xAxisG = timelineChart.g.append("g").attr("transform", `translate(0,${innerH})`);
      timelineChart.yAxisG = timelineChart.g.append("g");

      timelineChart.path = timelineChart.g.append("path").attr("fill", "none").attr("stroke-width", 2);

      timelineChart.cursor = timelineChart.g.append("line")
        .attr("y1", 0).attr("y2", innerH)
        .attr("stroke", "rgba(229,231,235,.6)")
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "4 4");

      timelineChart.xAxisG.call(d3.axisBottom(timelineChart.x).ticks(6).tickFormat(d => convertMinutesToTime(Math.round(d))));
      timelineChart.yAxisG.call(d3.axisLeft(timelineChart.y).ticks(5));

      window.addEventListener("resize", () => {
        initTimelineChart();
        updateTimelineChart(tim, selectedProbe.raceKey, selectedProbe.segIndex);
      });

      timelineChart.svg.on("click", () => {
        timelineChart.zoom = !timelineChart.zoom;
        updateTimelineChart(tim, selectedProbe.raceKey, selectedProbe.segIndex);
      });
    }

    function showStatusTable(reason){ timelineMode = "table"; lastStatusReason = reason; renderStatusTable(tim); }

    function sumRow(row){
      if (!row) return 0;
      let s = 0;
      for (let i = 0; i < row.length; i++) {
        const v = row[i];
        if (typeof v === "number" && isFinite(v)) s += v;
      }
      return s;
    }

    const BUCKET_SIZE_25M = 4;

    function getDensityRowAbsTime(raceKey, timAbsMinutes) {
      const kk = Math.max(0, Math.round(timAbsMinutes - delay[raceKey]));
      if (!woist[raceKey] || kk < 0 || kk >= woist[raceKey].length) return null;
      return woist[raceKey][kk];
    }

    function runnersPer100mFromRow(row, segIndex25m) {
      if (!row) return 0;
      const b0 = Math.floor(segIndex25m / BUCKET_SIZE_25M) * BUCKET_SIZE_25M;
      let s = 0;
      for (let j = 0; j < BUCKET_SIZE_25M; j++) {
        const v = row[b0 + j];
        if (typeof v === "number" && isFinite(v)) s += v;
      }
      return s;
    }

    function getWoistRow(raceKey, kk){
      if (!woist[raceKey] || kk < 0 || kk >= woist[raceKey].length) return null;
      return woist[raceKey][kk];
    }

    function showTimelineChart(){ timelineMode = "chart"; lastStatusReason = null; initTimelineChart(); updateTimelineChart(tim, selectedProbe.raceKey, selectedProbe.segIndex); }

    function getDensityAt(raceKey, timAbsMinutes, segIndex25m) {
      if (timAbsMinutes < delay[raceKey] || timAbsMinutes > cutoff[raceKey] + delay[raceKey]) return 0;
      const row = getDensityRowAbsTime(raceKey, timAbsMinutes);
      if (!row) return 0;
      return runnersPer100mFromRow(row, segIndex25m);
    }

    const raceLineColor = { mara:"red", half:"blue", tenkm:"green", fivekm:"pink", twofive:"#09ebdc" };

    function updateTimelineChart(timr, raceKey, segIndex) {
      if (!isRaceActive(raceKey)) {
        d3.select("#timelineChartTitle").text("race hidden");
        if (timelineChart.path) timelineChart.path.attr("d", null);
        return;
      }
      if (!timelineChart.svg) return;

      const innerW = timelineChart.width - timelineChart.margin.left - timelineChart.margin.right;
      const innerH = timelineChart.height - timelineChart.margin.top - timelineChart.margin.bottom;

      let t0 = 360, t1 = 900;
      if (timelineChart.zoom) {
        const w = timelineChart.zoomWindow;
        t0 = Math.max(360, Math.round(timr - w));
        t1 = Math.min(900, Math.round(timr + w));
        if (t1 - t0 < 2) { t0 = Math.max(360, t0 - 1); t1 = Math.min(900, t1 + 1); }
      }

      const data = [];
      let maxY = 0;
      for (let t = t0; t <= t1; t++) {
        const y = getDensityAt(raceKey, t, segIndex);
        data.push({ t, y });
        if (y > maxY) maxY = y;
      }

      const yMax = ceilToHundred(maxY * 1.15);
      timelineChart.x.domain([t0, t1]).range([0, innerW]);
      timelineChart.y.domain([0, yMax]).range([innerH, 0]);

      timelineChart.xAxisG.attr("transform", `translate(0,${innerH})`)
        .call(d3.axisBottom(timelineChart.x).ticks(6).tickFormat(d => convertMinutesToTime(Math.round(d))));
      timelineChart.yAxisG.call(d3.axisLeft(timelineChart.y).ticks(5));

      const line = d3.line().x(d => timelineChart.x(d.t)).y(d => timelineChart.y(d.y));
      timelineChart.path.attr("stroke", raceLineColor[raceKey] || "#fff").attr("d", line(data));

      const cx = timelineChart.x(timr);
      timelineChart.cursor.attr("x1", cx).attr("x2", cx).attr("y1", 0).attr("y2", innerH);

      const b0 = Math.floor(segIndex / BUCKET_SIZE_25M) * BUCKET_SIZE_25M;
      const km = (b0 + BUCKET_SIZE_25M / 2) / 40;
      d3.select("#timelineChartTitle").text(`Runners per 100m of the ${racenames[raceKey] || raceKey} at ${km.toFixed(2)} km`);
    }

    initTimelineChart();

    const distanceChart = { svg:null, g:null, width:0, height:0, margin:{top:10,right:16,bottom:28,left:46}, x:null, y:null, xAxisG:null, yAxisG:null, pathsG:null };

    function initDistanceChart() {
      const container = document.getElementById("chartDistance");
      if (!container) return;
      d3.select(container).selectAll("*").remove();

      const rect = container.getBoundingClientRect();
      distanceChart.width = Math.max(320, rect.width);
      distanceChart.height = Math.max(180, rect.height);

      const innerW = distanceChart.width - distanceChart.margin.left - distanceChart.margin.right;
      const innerH = distanceChart.height - distanceChart.margin.top - distanceChart.margin.bottom;

      distanceChart.svg = d3.select(container).append("svg").attr("width", distanceChart.width).attr("height", distanceChart.height);
      distanceChart.g = distanceChart.svg.append("g").attr("transform", `translate(${distanceChart.margin.left},${distanceChart.margin.top})`);

      distanceChart.x = d3.scaleLinear().domain([0, 42]).range([0, innerW]);
      distanceChart.y = d3.scaleLinear().domain([0, 200]).range([innerH, 0]);

      distanceChart.xAxisG = distanceChart.g.append("g").attr("transform", `translate(0,${innerH})`);
      distanceChart.yAxisG = distanceChart.g.append("g");
      distanceChart.pathsG = distanceChart.g.append("g");

      distanceChart.xAxisG.call(d3.axisBottom(distanceChart.x).ticks(7).tickFormat(d => `${d} km`));
      distanceChart.yAxisG.call(d3.axisLeft(distanceChart.y).ticks(5));

      window.addEventListener("resize", () => { initDistanceChart(); updateDistanceChart(tim); });
    }

    function syncPlayUI() {
      d3.select('#playbut').text(play ? 'stop' : 'play');
      d3.select('#realbutton').text(realtime ? 'stop' : 'realtime');
    }

    function renderStatusTable(timAbsMinutes){
      const container = document.getElementById("chartTime");
      if (!container) return;
      d3.select(container).selectAll("*").remove();

      const title = document.getElementById("timelineChartTitle");
      if (title) {
        const when = convertMinutesToTime(Math.round(timAbsMinutes));
        const where = lastStatusReason ? ` – ${lastStatusReason.toUpperCase()}` : "";
        title.textContent = `Race status at ${when}${where}`;
      }

      const wrap = d3.select(container).append("div").style("width", "100%").style("height", "100%").style("overflow", "auto");

      wrap.append("button")
        .attr("class", "btn btn--ghost")
        .style("margin", "0 0 10px 0")
        .text("back to timeline")
        .on("click", showTimelineChart);

      const table = wrap.append("table").style("width", "100%").style("border-collapse", "collapse").style("font-size", "13px");
      const thead = table.append("thead");
      const tbody = table.append("tbody");

      const cols = ["race", "start area", "on course", "finish area", "have left"];
      thead.append("tr").selectAll("th").data(cols).enter().append("th")
        .text(d => d)
        .style("text-align", "left")
        .style("padding", "8px 8px")
        .style("border-bottom", "1px solid rgba(31,42,68,.8)")
        .style("color", "rgba(229,231,235,.9)");

      const tableKeys = [];
      ["half","tenkm","fivekm","twofive","mara"].forEach(k => { if (isRaceActive(k)) tableKeys.push(k); });

      const rows = tableKeys.map(k => {
        const c = getRaceStatusCounts(k, timAbsMinutes);
        return { key: k, race: racenames[k] || k, waiting: c.waiting, onCourse: c.onCourse, finished: c.finishedInArea, left: c.leftFinishArea };
      });

      const fmt = (v) => (v === null || v === undefined) ? "—" : String(Math.round(v));
      const tr = tbody.selectAll("tr").data(rows).enter().append("tr").style("border-bottom", "1px solid rgba(31,42,68,.35)");

      tr.selectAll("td")
        .data(d => [d.race, fmt(d.waiting), fmt(d.onCourse), fmt(d.finished), fmt(d.left)])
        .enter()
        .append("td")
        .text(d => d)
        .style("padding", "8px 8px")
        .style("color", "rgba(229,231,235,.88)");
    }

    const FINISH_DWELL_MIN = 6;

    function getRaceStatusCounts(raceKey, timAbsMinutes){
      if (timAbsMinutes < delay[raceKey]) return { waiting: 0, onCourse: 0, finishedInArea: 0, leftFinishArea: 0 };

      let kk = Math.round(timAbsMinutes - delay[raceKey]);
      const lastK = (woist[raceKey] && woist[raceKey].length) ? (woist[raceKey].length - 1) : 0;
      kk = Math.max(0, Math.min(kk, lastK));

      const kkPrev = Math.max(0, kk - FINISH_DWELL_MIN);

      const rowK = getWoistRow(raceKey, kk);
      const rowPrev = getWoistRow(raceKey, kkPrev);

      if (!rowK) return { waiting: 0, onCourse: 0, finishedInArea: 0, leftFinishArea: 0 };

      const totalStarters = starterzahlen[raceKey];
      const sumNow = sumRow(rowK);
      const sumPrev = rowPrev ? sumRow(rowPrev) : totalStarters;

      const waiting = rowK[0] || 0;
      const onCourse = Math.max(0, sumNow - waiting);

      const finishedTotalNow = Math.max(0, totalStarters - sumNow);
      const finishedTotalPrev = Math.max(0, totalStarters - sumPrev);

      const finishedInArea = Math.max(0, finishedTotalNow - finishedTotalPrev);
      const leftFinishArea = finishedTotalPrev;

      return { waiting, onCourse, finishedInArea, leftFinishArea };
    }

    function updateDistanceChart(timr) {
      d3.select("#chartDistanceTitle").text(`Runners per 100m at ${convertMinutesToTime(Math.round(timr))}`);
      if (!distanceChart.svg) return;

      const innerW = distanceChart.width - distanceChart.margin.left - distanceChart.margin.right;
      const innerH = distanceChart.height - distanceChart.margin.top - distanceChart.margin.bottom;

      function getDensityRow(raceKey, kk) {
        if (!woist[raceKey] || kk < 0 || kk >= woist[raceKey].length) return null;
        return woist[raceKey][kk];
      }

      const series = keys.filter(isRaceActive).map(raceKey => {
        const kk = Math.max(0, Math.round(timr - delay[raceKey]));
        const row = getDensityRow(raceKey, kk);
        if (!row) return { key: raceKey, values: [] };

        const segCount = Math.max(0, (coordinates[raceKey]?.length || 0) - 1);
        const BUCKET_SIZE = 4;
        const values = [];

        for (let i = 0; i < segCount; i += BUCKET_SIZE) {
          let bucketSum = 0;
          for (let j = 0; j < BUCKET_SIZE; j++) {
            const v = row[i + j];
            if (typeof v === "number" && isFinite(v)) bucketSum += v;
          }
          const distKm = ((i + BUCKET_SIZE / 2) / 40);
          const density = bucketSum;

          if (density > 0 && timr >= delay[raceKey] && timr <= cutoff[raceKey] + delay[raceKey]) {
            values.push({ x: distKm, y: density });
          }
        }
        return { key: raceKey, values };
      });

      const yMax = 500;
      distanceChart.y.domain([0, yMax]).range([innerH, 0]);

      distanceChart.x.range([0, innerW]);
      distanceChart.xAxisG
        .attr("transform", `translate(0,${innerH})`)
        .call(d3.axisBottom(distanceChart.x).ticks(7).tickFormat(d => `${d} km`));

      distanceChart.yAxisG.call(d3.axisLeft(distanceChart.y).ticks(5));

      const line = d3.line().x(d => distanceChart.x(d.x)).y(d => distanceChart.y(d.y)).defined(d => d && typeof d.y === "number");

      const paths = distanceChart.pathsG.selectAll("path.distance-line").data(series, d => d.key);

      paths.enter()
        .append("path")
        .attr("class", "distance-line")
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .merge(paths)
        .attr("stroke", d => raceLineColor[d.key] || "#ffffff")
        .attr("opacity", d => (d.values.length ? 0.95 : 0.15))
        .attr("d", d => line(d.values));

      paths.exit().remove();
    }

    function findIndices(arr) {
      let firstIndex = -1;
      let lastIndex = -1;
      if (!arr) { arr = [0]; }
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] > 0) {
          if (firstIndex === -1) firstIndex = i;
          lastIndex = i;
        }
      }
      if (lastIndex > coordinates.mara.length - 5 || lastIndex == NaN || lastIndex < 0) lastIndex = 0;
      if (firstIndex > coordinates.mara.length - 5 || firstIndex == NaN || firstIndex < 0) firstIndex = 0;
      return [ lastIndex, firstIndex ];
    }

    function coordinatesToGeoJSON(coordinatesArr) {
      if (!Array.isArray(coordinatesArr) || coordinatesArr.some(coord => !Array.isArray(coord) || coord.length !== 2)) {
        throw new Error('Invalid input: coordinates should be an array of [longitude, latitude] arrays.');
      }
      return {
        type: 'FeatureCollection',
        features: coordinatesArr.map(coord => ({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coord },
          properties: { radius: 0, stroke: 0, text: "empty", fill:"#000" }
        }))
      };
    }

    function generateColoredGeoJSON(coordinatesArr) {
      const colors = ['#ff0000', '#00ff00', '#ffff00', '#0000ff'];
      let features = [];
      for (let i = 0; i < coordinatesArr.length - 1; i++) {
        let colorIndex = i % colors.length;
        features.push({
          type: "Feature",
          properties: { radius: 0, width: 0, stroke: colors[colorIndex], segIndex: i, km: (i + 0.5) / 40 },
          geometry: { type: "LineString", coordinates: [ coordinatesArr[i], coordinatesArr[i + 1] ] }
        });
      }
      return { type: "FeatureCollection", features: features };
    }

    initDistanceChart();

    function initialise_map() {
     mapboxgl.accessToken = window.MAPBOX_TOKEN || "";
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v11',
        center: coordinates.mara[0],
        maxBounds: [
          [coordinates.mara[100][0] - 0.06, coordinates.mara[100][1] - 0.09],
          [coordinates.mara[100][0] + 0.06, coordinates.mara[100][1] + 0.045]
        ],
        dragRotate: true,
        zoom: 14,
        minZoom: 13,
        maxZoom: 16,
        pitch: 45,
        minPitch: 0,
        maxPitch: 75,
        bearing: 0
      });

      map.on('load', function () {
        map.addLayer({
          id: '3d-buildings',
          source: 'composite',
          'source-layer': 'building',
          filter: ['==', 'extrude', 'true'],
          type: 'fill-extrusion',
          minzoom: 13,
          paint: {
            'fill-extrusion-color': '#aaa',
            'fill-extrusion-height': ['interpolate', ['linear'], ['zoom'], 15, 0, 15.05, ['get', 'height']],
            'fill-extrusion-base': ['interpolate', ['linear'], ['zoom'], 15, 0, 15.05, ['get', 'min_height']],
            'fill-extrusion-opacity': 0.6
          }
        });

        var popup = new mapboxgl.Popup({ closeButton: false, closeOnClick: false });

        for (const key in coordinates) {
          map.addSource('line-segments' + key, { type: "geojson", data: linejsons[key] });
          map.addLayer({ id: "lines-layer-" + key, type: "line", source: "line-segments" + key, paint: { "line-width": ['get', 'width'], "line-color": ['get', 'stroke'] } });

          map.addSource('circles' + key, { type: "geojson", data: pointjsons[key] });
          map.addLayer({
            id: "circles-layer-" + key,
            type: "circle",
            source: "circles" + key,
            paint: {
              'circle-radius': ['get','radius'],
              'circle-opacity': 0.9,
              'circle-color': ['get', 'fill'],
              'circle-stroke-color': 'black',
              'circle-stroke-width': ['get', 'stroke']
            }
          });

          map.on('click', "lines-layer-" + key, (function(raceKey){
            return function(e){
              if (!e.features || !e.features.length) return;
              const segIndex = e.features[0].properties && e.features[0].properties.segIndex;
              if (segIndex === undefined || segIndex === null) return;
              selectedProbe.raceKey = raceKey;
              selectedProbe.segIndex = +segIndex;
              updateTimelineChart(tim, selectedProbe.raceKey, selectedProbe.segIndex);
            };
          })(key));

          map.on('mouseenter', "circles-layer-" + key, function (e) {
            map.getCanvas().style.cursor = 'pointer';
            var c = e.features[0].geometry.coordinates.slice();
            var text = e.features[0].properties.text;
            popup.setLngLat(c).setHTML(text).addTo(map);
          });

          map.on('mouseleave', "circles-layer-" + key, function () {
            map.getCanvas().style.cursor = '';
            popup.remove();
          });
        }

        map.addControl(new mapboxgl.NavigationControl({ showCompass: true, showZoom: true, showPitch: true }));

        waypoints = [
          { name:"Finish", coordinates: coordinates.mara[coordinates.mara.length-1], icon:'url(./finish.png)' },
          { name:"Start", coordinates: coordinates.mara[0], icon:'url(./start.png)' },
          { name:"42 elite", coordinates:[0,0], icon:'url(./42.png)' },
          { name:"42 last", coordinates:[0,0], icon:'url(./42B.png)' },
          { name:"21 elite", coordinates:[0,0], icon:'url(./21.png)' },
          { name:"21 last", coordinates:[0,0], icon:'url(./21B.png)' },
          { name:"10 km first", coordinates:[0,0], icon:'url(./10.png)' },
          { name:"10 km last", coordinates:[0,0], icon:'url(./10B.png)' },
          { name:"5 km first", coordinates:[0,0], icon:'url(./5.png)' },
          { name:"5 km  last", coordinates:[0,0], icon:'url(./5B.png)' },
          { name:"3 km first", coordinates:[0,0], icon:'url(./25.png)' },
          { name:"3 km last", coordinates:[0,0], icon:'url(./25B.png)' },
          { name:"diversion last", coordinates:[0,0], icon:'url(./42C.png)' }
        ];

        markers = [];
        waypoints.forEach(waypoint => {
          const el = document.createElement('div');
          el.className = 'marker';
          el.style.backgroundImage = waypoint.icon;
          el.style.width = '32px';
          el.style.height = '32px';
          el.style.backgroundSize = '100%';

          if (waypoint.name === "Start") el.addEventListener("click", (e) => { e.stopPropagation(); showStatusTable("start"); });
          if (waypoint.name === "Finish") el.addEventListener("click", (e) => { e.stopPropagation(); showStatusTable("finish"); });

          temp = new mapboxgl.Marker(el, { offset: [0, -16] })
            .setLngLat(waypoint.coordinates)
            .setPopup(new mapboxgl.Popup({ offset: 25 }).setText(waypoint.name))
            .addTo(map);

          markers.push(temp);
        });

        map.on('zoom', function() { d3.select('#gu3').property('value', Math.round(map.getZoom()*10)/10); });
        map.on('pitch', function() { d3.select('#gu1').property('value', 90 - Math.round(map.getPitch())); });
        map.on('move', function() { d3.select('#gu2').property('value', Math.round(map.getBearing())); });

        // initial render
        zeitgewahlt(Math.round(tim));
      });
    }
  </script>
</body>
</html>
